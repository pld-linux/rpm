--- ./lib/depends.c.org	Mon Jun 25 17:59:49 2001
+++ ./lib/depends.c	Mon Jun 25 18:04:00 2001
@@ -335,18 +335,21 @@
 	for (dirNum = 0; dirNum < numDirs; dirNum++) {
 	    dirNeedle.dirName = (char *) dirNames[dirNum];
 	    dirNeedle.dirNameLen = strlen(dirNames[dirNum]);
-	    dirMatch = bsearch(&dirNeedle, al->dirs, origNumDirs,
+	    dirMatch = bsearchnl(&dirNeedle, al->dirs, al->numDirs,
 			       sizeof(dirNeedle), dirInfoCompare);
-	    if (dirMatch) {
-		dirMapping[dirNum] = dirMatch - al->dirs;
-	    } else {
-		dirMapping[dirNum] = al->numDirs;
-		al->dirs[al->numDirs].dirName = xstrdup(dirNames[dirNum]);
-		al->dirs[al->numDirs].dirNameLen = strlen(dirNames[dirNum]);
-		al->dirs[al->numDirs].files = NULL;
-		al->dirs[al->numDirs].numFiles = 0;
+	    if (dirMatch==NULL || dirInfoCompare(dirMatch, &dirNeedle)!=0) {
+		if(dirMatch==NULL)
+			dirMatch=al->dirs+al->numDirs;
+		memmove(dirMatch+1, dirMatch, 
+			((al->dirs+al->numDirs) - dirMatch)*sizeof(*al->dirs));
+		dirMatch->dirName = xstrdup(dirNames[dirNum]);
+		dirMatch->dirNameLen = strlen(dirNames[dirNum]);
+		dirMatch->files = NULL;
+		dirMatch->numFiles = 0;
 		al->numDirs++;
 	    }
+	    dirMapping[dirNum] = dirMatch - al->dirs;
+	
 	}
 
 	free(dirNames);
@@ -374,9 +377,6 @@
 
 	    first = last + 1;
 	}
-
-	if (origNumDirs + al->numDirs)
-	    qsort(al->dirs, al->numDirs, sizeof(dirNeedle), dirInfoCompare);
 
     }
 
--- ./lib/misc.c.org	Mon Jun 25 17:59:49 2001
+++ ./lib/misc.c	Mon Jun 25 18:04:36 2001
@@ -869,3 +869,39 @@
 		&pEVR, 1);
     }
 }
+
+/* Based on glibc's function bsearch.
+ * Modified by Pawel Kolodziej <pawelk@pld.org.pl>
+ * Perform a binary search for KEY in BASE which has NMEMB elements
+ * of SIZE bytes each.  The comparisons are done by (*COMPAR)(). 
+ * Return element not less then KEY. Return NULL if all elements are 
+ * less then KEY
+ */
+void *
+bsearchnl (const void *key, const void *base, size_t nmemb, size_t size,
+	 int (*compar) (const void *, const void *))
+{
+  size_t l, u, idx;
+  const void *p;
+  int comparison;
+
+  l = 0;
+  u = nmemb;
+  while (l < u)
+    {
+      idx = (l + u) / 2;
+      p = (void *) (((const char *) base) + (idx * size));
+      comparison = (*compar) (key, p);
+      if (comparison < 0)
+	u = idx;
+      else if (comparison > 0)
+	l = idx + 1;
+      else
+	return (void *) p;
+    }
+  if(l > nmemb-1)
+	  return NULL;
+  p = (void *) (((const char *) base) + (l * size));
+  return (void *)p;
+}
+
--- ./lib/misc.h.org	Mon Jun 25 17:59:49 2001
+++ ./lib/misc.h	Mon Jun 25 18:01:53 2001
@@ -102,6 +102,12 @@
  */
 void providePackageNVR(Header h);
 
+
+void *
+bsearchnl (const void *key, const void *base, size_t nmemb, size_t size,
+	 int (*compar) (const void *, const void *));
+
+
 #ifdef __cplusplus
 }
 #endif
