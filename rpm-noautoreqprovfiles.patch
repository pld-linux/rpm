diff -durN rpm-4.3.orig/build/rpmfc.c rpm-4.3/build/rpmfc.c
--- rpm-4.3.orig/build/rpmfc.c	2004-01-04 16:05:16.000000000 +0100
+++ rpm-4.3/build/rpmfc.c	2004-01-04 17:48:35.453302966 +0100
@@ -1,6 +1,7 @@
 #include "system.h"
 
 #include <signal.h>	/* getOutputFrom() */
+#include <fnmatch.h>
 
 #include <rpmbuild.h>
 #include <argv.h>
@@ -639,9 +640,11 @@
 /**
  * Extract script dependencies.
  * @param fc		file classifier
+ * @param findprov	1 to enable provides
+ * @param findreq	1 to enable requires
  * @return		0 on success
  */
-static int rpmfcSCRIPT(rpmfc fc)
+static int rpmfcSCRIPT(rpmfc fc,int findprov,int findreq)
 	/*@globals rpmGlobalMacroContext, h_errno, fileSystem, internalState @*/
 	/*@modifies fc, rpmGlobalMacroContext, fileSystem, internalState @*/
 {
@@ -693,7 +696,7 @@
 	*se = '\0';
 	se++;
 
-	if (is_executable) {
+	if (is_executable && findreq) {
 	    /* Add to package requires. */
 	    ds = rpmdsSingle(RPMTAG_REQUIRENAME, s, "", RPMSENSE_FIND_REQUIRES);
 	    xx = rpmdsMerge(&fc->requires, ds);
@@ -720,19 +723,22 @@
     (void) fclose(fp);
 
     if (fc->fcolor->vals[fc->ix] & RPMFC_PERL) {
-	if (fc->fcolor->vals[fc->ix] & RPMFC_MODULE)
+	if (findprov && fc->fcolor->vals[fc->ix] & RPMFC_MODULE)
 	    xx = rpmfcHelper(fc, 'P', "perl");
-	if (is_executable || (fc->fcolor->vals[fc->ix] & RPMFC_MODULE))
+	if (findreq && (is_executable || (fc->fcolor->vals[fc->ix] & RPMFC_MODULE)))
 	    xx = rpmfcHelper(fc, 'R', "perl");
     }
     if (fc->fcolor->vals[fc->ix] & RPMFC_PYTHON) {
-	xx = rpmfcHelper(fc, 'P', "python");
-	if (is_executable)
+	if (findprov)
+	    xx = rpmfcHelper(fc, 'P', "python");
+	if (findreq && is_executable)
 	    xx = rpmfcHelper(fc, 'R', "python");
     }
     if (fc->fcolor->vals[fc->ix] & RPMFC_PHP) {
+            if (findprov)
 		xx = rpmfcHelper(fc, 'P', "php");
-	    xx = rpmfcHelper(fc, 'R', "php");
+            if (findreq)
+                xx = rpmfcHelper(fc, 'R', "php");
 	}
 
     return 0;
@@ -741,9 +747,11 @@
 /**
  * Extract Elf dependencies.
  * @param fc		file classifier
+ * @param findprov	1 to enable provides
+ * @param findreq	1 to enable requires
  * @return		0 on success
  */
-static int rpmfcELF(rpmfc fc)
+static int rpmfcELF(rpmfc fc,int findprov,int findreq)
 	/*@globals rpmGlobalMacroContext, h_errno, fileSystem, internalState @*/
 	/*@modifies fc, rpmGlobalMacroContext, fileSystem, internalState @*/
 {
@@ -855,17 +863,19 @@
 				t = stpcpy(t, "(64bit)");
 #endif
 			    t++;
+                            
+                            if (findprov) {
+                                /* Add to package provides. */
+                                ds = rpmdsSingle(RPMTAG_PROVIDES,
+                                            buf, "", RPMSENSE_FIND_PROVIDES);
+                                xx = rpmdsMerge(&fc->provides, ds);
 
-			    /* Add to package provides. */
-			    ds = rpmdsSingle(RPMTAG_PROVIDES,
-					buf, "", RPMSENSE_FIND_PROVIDES);
-			    xx = rpmdsMerge(&fc->provides, ds);
-
-			    /* Add to file dependencies. */
-			    xx = rpmfcSaveArg(&fc->ddict,
-					rpmfcFileDep(t, fc->ix, ds));
+                                /* Add to file dependencies. */
+                                xx = rpmfcSaveArg(&fc->ddict,
+                                            rpmfcFileDep(t, fc->ix, ds));
 
-			    ds = rpmdsFree(ds);
+                                ds = rpmdsFree(ds);
+                            }
 			}
 			auxoffset += aux->vda_next;
 		    }
@@ -916,15 +926,17 @@
 #endif
 			    t++;
 
-			    /* Add to package dependencies. */
-			    ds = rpmdsSingle(RPMTAG_REQUIRENAME,
-					buf, "", RPMSENSE_FIND_REQUIRES);
-			    xx = rpmdsMerge(&fc->requires, ds);
+                            if (findreq) {
+                                /* Add to package dependencies. */
+                                ds = rpmdsSingle(RPMTAG_REQUIRENAME,
+                                            buf, "", RPMSENSE_FIND_REQUIRES);
+                                xx = rpmdsMerge(&fc->requires, ds);
 
-			    /* Add to file dependencies. */
-			    xx = rpmfcSaveArg(&fc->ddict,
-					rpmfcFileDep(t, fc->ix, ds));
-			    ds = rpmdsFree(ds);
+                                /* Add to file dependencies. */
+                                xx = rpmfcSaveArg(&fc->ddict,
+                                            rpmfcFileDep(t, fc->ix, ds));
+                                ds = rpmdsFree(ds);
+                            }
 			}
 			auxoffset += aux->vna_next;
 		    }
@@ -949,6 +961,7 @@
 			/* Files with executable bit set only. */
 			if (fc->skipReq || !(st->st_mode & (S_IXUSR|S_IXGRP|S_IXOTH)))
 			    /*@innercontinue@*/ continue;
+                        if (!findreq) continue;
 			/* Add to package requires. */
 			depsp = &fc->requires;
 			tagN = RPMTAG_REQUIRENAME;
@@ -961,6 +974,7 @@
 			/* Add to package provides. */
 			if (fc->skipProv)
 			    /*@innercontinue@*/ continue;
+                        if (!findprov) continue;
 			depsp = &fc->provides;
 			tagN = RPMTAG_PROVIDENAME;
 			dsContext = RPMSENSE_FIND_PROVIDES;
@@ -999,7 +1013,7 @@
     /*@=branchstate =uniondef @*/
 
     /* For DSO's, provide the basename of the file if DT_SONAME not found. */
-    if (!fc->skipProv && isDSO && !gotSONAME) {
+    if (findprov && !fc->skipProv && isDSO && !gotSONAME) {
 	depsp = &fc->provides;
 	tagN = RPMTAG_PROVIDENAME;
 	dsContext = RPMSENSE_FIND_PROVIDES;
@@ -1047,7 +1061,7 @@
 }
 
 typedef struct rpmfcApplyTbl_s {
-    int (*func) (rpmfc fc);
+    int (*func) (rpmfc fc,int findprov,int findreq);
     int colormask;
 } * rpmfcApplyTbl;
 
@@ -1187,6 +1201,27 @@
     int ix;
     int i;
     int xx;
+    int j;
+    int findprov;
+    int findreq;
+    ARGV_t noautoreqfiles=NULL;
+    int noautoreqfiles_c;
+    ARGV_t noautoprovfiles=NULL;
+    int noautoprovfiles_c;
+
+    s=rpmExpand("%{buildroot}%{_noautoreqfiles}",NULL);
+    if (s) {
+    	poptParseArgvString(s,&noautoreqfiles_c,(const char ***)&noautoreqfiles);
+	    s = _free(s);
+    }
+    if (noautoreqfiles==NULL) noautoreqfiles_c=0;
+ 
+    s=rpmExpand("%{buildroot}%{_noautoprovfiles}",NULL);
+    if (s) {
+    	poptParseArgvString(s,&noautoprovfiles_c,(const char ***)&noautoprovfiles);
+	    s = _free(s);
+    }
+    if (noautoprovfiles==NULL) noautoprovfiles_c=0;
 
     /* Generate package and per-file dependencies. */
     for (fc->ix = 0; fc->fn[fc->ix] != NULL; fc->ix++) {
@@ -1194,10 +1229,33 @@
 	for (fcat = rpmfcApplyTable; fcat->func != NULL; fcat++) {
 	    if (!(fc->fcolor->vals[fc->ix] & fcat->colormask))
 		/*@innercontinue@*/ continue;
-	    xx = (*fcat->func) (fc);
+            findprov=1;
+            for(j=0;j<noautoprovfiles_c;j++) {
+                if (fnmatch(noautoprovfiles[j],fc->fn[fc->ix],0)==0) {
+                    rpmMessage(RPMMESS_NORMAL, 
+                            "skipping %s provides detection (matches noautoprovfiles pattern: %s)\n",
+                            fc->fn[fc->ix],noautoprovfiles[j]);
+            	    findprov=0;
+                    break;
+                }
+	    }
+            findreq=1;
+            for(j=0;j<noautoreqfiles_c;j++) {
+                if (fnmatch(noautoreqfiles[j],fc->fn[fc->ix],0)==0) {
+                    rpmMessage(RPMMESS_NORMAL, 
+                            "skipping %s requires detection (matches noautoreqfiles pattern: %s)\n",
+                            fc->fn[fc->ix],noautoreqfiles[j]);
+            	    findreq=0;
+                    break;
+                }
+	    }
+	    xx = (*fcat->func) (fc,findprov,findreq);
 	}
     }
 
+    noautoreqfiles=_free(noautoreqfiles);
+    noautoprovfiles=_free(noautoprovfiles);
+
     rpmfcFindRequiredPackages(fc);
 
 /*@-boundswrite@*/
