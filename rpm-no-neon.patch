--- rpm-4.5/rpmio/rpmdav.c~	2008-07-09 12:38:31.000000000 +0300
+++ rpm-4.5/rpmio/rpmdav.c	2008-09-04 17:43:50.215697868 +0300
@@ -9,58 +9,6 @@
 #include <pthread.h>
 #endif
 
-#if USE_INTERNAL_NEON
-#include "ne_alloc.h"
-#include "ne_auth.h"
-#include "ne_basic.h"
-#include "ne_dates.h"
-#include "ne_locks.h"
-#else
-#include "neon/ne_alloc.h"
-#include "neon/ne_auth.h"
-#include "neon/ne_basic.h"
-#include "neon/ne_dates.h"
-#include "neon/ne_locks.h"
-#endif
-
-#define	NEONBLOWSCHUNKS
-#ifndef	NEONBLOWSCHUNKS
-/* HACK: include ne_private.h to access sess->socket for now. */
-#include "../neon/src/ne_private.h"
-#endif
-
-#if USE_INTERNAL_NEON
-#include "ne_props.h"
-#include "ne_request.h"
-#include "ne_socket.h"
-#include "ne_string.h"
-#include "ne_utils.h"
-#include "ne_md5.h" /* for version detection only */
-#else
-#include "neon/ne_props.h"
-#include "neon/ne_request.h"
-#include "neon/ne_socket.h"
-#include "neon/ne_string.h"
-#include "neon/ne_utils.h"
-#include "neon/ne_md5.h" /* for version detection only */
-#endif
-
-/* poor-man's NEON version determination */
-#if defined(NE_MD5_H)
-#define WITH_NEON_MIN_VERSION 0x002700
-#elif defined(NE_FEATURE_I18N)
-#define WITH_NEON_MIN_VERSION 0x002600
-#else
-#define WITH_NEON_MIN_VERSION 0x002500
-#endif
-
-/* XXX API changes for NEON 0.26 */
-#if WITH_NEON_MIN_VERSION >= 0x002600
-#define	ne_set_persist(_sess, _flag)
-#define	ne_propfind_set_private(_pfh, _create_item, NULL) \
-	ne_propfind_set_private(_pfh, _create_item, NULL, NULL)
-#endif
-
 #include <rpmio_internal.h>
 
 #define _RPMDAV_INTERNAL
@@ -74,1469 +22,6 @@
 /*@access FD_t @*/
 /*@access urlinfo @*/
 
-#if 0	/* HACK: reasonable value needed. */
-#define TIMEOUT_SECS 60
-#else
-#define TIMEOUT_SECS 5
-#endif
-/*@unchecked@*/
-static int httpTimeoutSecs = TIMEOUT_SECS;
-
-/* =============================================================== */
-int davFree(urlinfo u)
-	/*@globals internalState @*/
-	/*@modifies u, internalState @*/
-{
-    if (u != NULL) {
-	if (u->sess != NULL) {
-	    ne_session_destroy(u->sess);
-	    u->sess = NULL;
-	}
-	switch (u->urltype) {
-	default:
-	    /*@notreached@*/ break;
-	case URL_IS_HTTPS:
-	case URL_IS_HTTP:
-	case URL_IS_HKP:
-	    u->capabilities = _free(u->capabilities);
-	    if (u->lockstore != NULL)
-		ne_lockstore_destroy(u->lockstore);
-	    u->lockstore = NULL;
-	    ne_sock_exit();
-	    break;
-	}
-    }
-    return 0;
-}
-
-static void davProgress(void * userdata, off_t current, off_t total)
-	/*@*/
-{
-    urlinfo u = userdata;
-    ne_session * sess;
-
-assert(u != NULL);
-    sess = u->sess;
-assert(sess != NULL);
-assert(u == ne_get_session_private(sess, "urlinfo"));
-
-    u->current = current;
-    u->total = total;
-
-if (_dav_debug < 0)
-fprintf(stderr, "*** davProgress(%p,0x%x:0x%x) sess %p u %p\n", userdata, (unsigned int)current, (unsigned int)total, sess, u);
-}
-
-#if WITH_NEON_MIN_VERSION >= 0x002700
-static void davNotify(void * userdata,
-		ne_session_status connstatus, const ne_session_status_info *info)
-#else
-static void davNotify(void * userdata,
-		ne_conn_status connstatus, const char * info)
-#endif
-	/*@*/
-{
-    urlinfo u = userdata;
-    ne_session * sess;
-    /*@observer@*/
-    static const char * connstates[] = {
-	"namelookup",
-	"connecting",
-	"connected",
-	"secure",
-	"unknown"
-    };
-
-assert(u != NULL);
-    sess = u->sess;
-assert(sess != NULL);
-assert(u == ne_get_session_private(sess, "urlinfo"));
-
-#ifdef	REFERENCE
-typedef enum {
-    ne_conn_namelookup, /* lookup up hostname (info = hostname) */
-    ne_conn_connecting, /* connecting to host (info = hostname) */
-    ne_conn_connected, /* connected to host (info = hostname) */
-    ne_conn_secure /* connection now secure (info = crypto level) */
-} ne_conn_status;
-#endif
-
-#if WITH_NEON_MIN_VERSION < 0x002700
-    u->connstatus = connstatus;
-#endif
-
-/*@-boundsread@*/
-if (_dav_debug < 0)
-fprintf(stderr, "*** davNotify(%p,%d,%p) sess %p u %p %s\n", userdata, connstatus, info, sess, u, connstates[ (connstatus < 4 ? connstatus : 4)]);
-/*@=boundsread@*/
-
-}
-
-static void davCreateRequest(ne_request * req, void * userdata,
-		const char * method, const char * uri)
-	/*@*/
-{
-    urlinfo u = userdata;
-    ne_session * sess;
-    void * private = NULL;
-    const char * id = "urlinfo";
-
-assert(u != NULL);
-assert(u->sess != NULL);
-assert(req != NULL);
-    sess = ne_get_session(req);
-assert(sess == u->sess);
-assert(u == ne_get_session_private(sess, "urlinfo"));
-
-assert(sess != NULL);
-    private = ne_get_session_private(sess, id);
-assert(u == private);
-
-if (_dav_debug < 0)
-fprintf(stderr, "*** davCreateRequest(%p,%p,%s,%s) %s:%p\n", req, userdata, method, uri, id, private);
-}
-
-static void davPreSend(ne_request * req, void * userdata, ne_buffer * buf)
-{
-    urlinfo u = userdata;
-    ne_session * sess;
-    const char * id = "fd";
-    FD_t fd = NULL;
-
-assert(u != NULL);
-assert(u->sess != NULL);
-assert(req != NULL);
-    sess = ne_get_session(req);
-assert(sess == u->sess);
-assert(u == ne_get_session_private(sess, "urlinfo"));
-
-    fd = ne_get_request_private(req, id);
-
-if (_dav_debug < 0)
-fprintf(stderr, "*** davPreSend(%p,%p,%p) sess %p %s %p\n", req, userdata, buf, sess, id, fd);
-if (_dav_debug)
-fprintf(stderr, "-> %s\n", buf->data);
-
-}
-
-static int davPostSend(ne_request * req, void * userdata, const ne_status * status)
-	/*@*/
-{
-    urlinfo u = userdata;
-    ne_session * sess;
-    const char * id = "fd";
-    FD_t fd = NULL;
-
-assert(u != NULL);
-assert(u->sess != NULL);
-assert(req != NULL);
-    sess = ne_get_session(req);
-assert(sess == u->sess);
-assert(u == ne_get_session_private(sess, "urlinfo"));
-
-    fd = ne_get_request_private(req, id);
-
-/*@-evalorder@*/
-if (_dav_debug < 0)
-fprintf(stderr, "*** davPostSend(%p,%p,%p) sess %p %s %p %s\n", req, userdata, status, sess, id, fd, ne_get_error(sess));
-/*@=evalorder@*/
-    return NE_OK;
-}
-
-static void davDestroyRequest(ne_request * req, void * userdata)
-	/*@*/
-{
-    urlinfo u = userdata;
-    ne_session * sess;
-    const char * id = "fd";
-    FD_t fd = NULL;
-
-assert(u != NULL);
-assert(u->sess != NULL);
-assert(req != NULL);
-    sess = ne_get_session(req);
-assert(sess == u->sess);
-assert(u == ne_get_session_private(sess, "urlinfo"));
-
-    fd = ne_get_request_private(req, id);
-
-if (_dav_debug < 0)
-fprintf(stderr, "*** davDestroyRequest(%p,%p) sess %p %s %p\n", req, userdata, sess, id, fd);
-}
-
-static void davDestroySession(void * userdata)
-	/*@*/
-{
-    urlinfo u = userdata;
-    ne_session * sess;
-    void * private = NULL;
-    const char * id = "urlinfo";
-
-assert(u != NULL);
-assert(u->sess != NULL);
-    sess = u->sess;
-assert(u == ne_get_session_private(sess, "urlinfo"));
-
-assert(sess != NULL);
-    private = ne_get_session_private(sess, id);
-assert(u == private);
-
-if (_dav_debug < 0)
-fprintf(stderr, "*** davDestroySession(%p) sess %p %s %p\n", userdata, sess, id, private);
-}
-
-static int
-davVerifyCert(void *userdata, int failures, const ne_ssl_certificate *cert)
-	/*@*/
-{
-    const char *hostname = userdata;
-
-if (_dav_debug < 0)
-fprintf(stderr, "*** davVerifyCert(%p,%d,%p) %s\n", userdata, failures, cert, hostname);
-
-    return 0;	/* HACK: trust all server certificates. */
-}
-
-static int davConnect(urlinfo u)
-	/*@globals internalState @*/
-	/*@modifies u, internalState @*/
-{
-    const char * path = NULL;
-    int rc;
-
-    /* HACK: hkp:// has no steenkin' options */
-    if (!(u->urltype == URL_IS_HTTP || u->urltype == URL_IS_HTTPS))
-	return 0;
-
-    /* HACK: where should server capabilities be read? */
-    (void) urlPath(u->url, &path);
-    /* HACK: perhaps capture Allow: tag, look for PUT permitted. */
-    /* XXX [hdr] Allow: GET,HEAD,POST,OPTIONS,TRACE */
-    rc = ne_options(u->sess, path, u->capabilities);
-    switch (rc) {
-    case NE_OK:
-    {	ne_server_capabilities *cap = u->capabilities;
-	if (cap->dav_class1)
-	    u->allow |= RPMURL_SERVER_HASDAVCLASS1;
-	else
-	    u->allow &= ~RPMURL_SERVER_HASDAVCLASS1;
-	if (cap->dav_class2)
-	    u->allow |= RPMURL_SERVER_HASDAVCLASS2;
-	else
-	    u->allow &= ~RPMURL_SERVER_HASDAVCLASS2;
-	if (cap->dav_executable)
-	    u->allow |= RPMURL_SERVER_HASDAVEXEC;
-	else
-	    u->allow &= ~RPMURL_SERVER_HASDAVEXEC;
-    }	break;
-    case NE_ERROR:
-	/* HACK: "301 Moved Permanently" on empty subdir. */
-	if (!strncmp("301 ", ne_get_error(u->sess), sizeof("301 ")-1))
-	    break;
-	errno = EIO;		/* HACK: more precise errno. */
-	goto bottom;
-    case NE_LOOKUP:
-	errno = ENOENT;		/* HACK: errno same as non-existent path. */
-	goto bottom;
-    case NE_CONNECT:		/* HACK: errno set already? */
-    default:
-bottom:
-if (_dav_debug)
-fprintf(stderr, "*** Connect to %s:%d failed(%d):\n\t%s\n",
-		   u->host, u->port, rc, ne_get_error(u->sess));
-	break;
-    }
-
-    /* HACK: sensitive to error returns? */
-    u->httpVersion = (ne_version_pre_http11(u->sess) ? 0 : 1);
-
-    return rc;
-}
-
-static int davInit(const char * url, urlinfo * uret)
-	/*@globals internalState @*/
-	/*@modifies *uret, internalState @*/
-{
-    urlinfo u = NULL;
-    int rc = 0;
-
-/*@-globs@*/	/* FIX: h_errno annoyance. */
-    if (urlSplit(url, &u))
-	return -1;	/* XXX error returns needed. */
-/*@=globs@*/
-
-    if (u->url != NULL && u->sess == NULL)
-    switch (u->urltype) {
-    default:
-	assert(u->urltype != u->urltype);
-	/*@notreached@*/ break;
-    case URL_IS_HTTPS:
-    case URL_IS_HTTP:
-    case URL_IS_HKP:
-      {	ne_server_capabilities * capabilities;
-
-	/* HACK: oneshots should be done Somewhere Else Instead. */
-/*@-noeffect@*/
-	rc = ((_dav_debug < 0) ? NE_DBG_HTTP : 0);
-	ne_debug_init(stderr, rc);		/* XXX oneshot? */
-/*@=noeffect@*/
-	rc = ne_sock_init();			/* XXX oneshot? */
-
-	u->lockstore = ne_lockstore_create();	/* XXX oneshot? */
-
-	u->capabilities = capabilities = xcalloc(1, sizeof(*capabilities));
-	u->sess = ne_session_create(u->scheme, u->host, u->port);
-
-	ne_lockstore_register(u->lockstore, u->sess);
-
-	if (u->proxyh != NULL)
-	    ne_session_proxy(u->sess, u->proxyh, u->proxyp);
-
-#if 0
-	{   const ne_inet_addr ** addrs;
-	    unsigned int n;
-	    ne_set_addrlist(u->sess, addrs, n);
-	}
-#endif
-
-	ne_set_progress(u->sess, davProgress, u);
-#if WITH_NEON_MIN_VERSION >= 0x002700
-	ne_set_notifier(u->sess, davNotify, u);
-#else
-	ne_set_status(u->sess, davNotify, u);
-#endif
-
-	ne_set_persist(u->sess, 1);
-	ne_set_read_timeout(u->sess, httpTimeoutSecs);
-	ne_set_useragent(u->sess, PACKAGE "/" PACKAGE_VERSION);
-
-	/* XXX check that neon is ssl enabled. */
-	if (!strcasecmp(u->scheme, "https"))
-	    ne_ssl_set_verify(u->sess, davVerifyCert, (char *)u->host);
-
-	ne_set_session_private(u->sess, "urlinfo", u);
-
-	ne_hook_destroy_session(u->sess, davDestroySession, u);
-
-	ne_hook_create_request(u->sess, davCreateRequest, u);
-	ne_hook_pre_send(u->sess, davPreSend, u);
-	ne_hook_post_send(u->sess, davPostSend, u);
-	ne_hook_destroy_request(u->sess, davDestroyRequest, u);
-
-	/* HACK: where should server capabilities be read? */
-	rc = davConnect(u);
-	if (rc)
-	    goto exit;
-      }	break;
-    }
-
-exit:
-/*@-boundswrite@*/
-    if (uret != NULL)
-	*uret = urlLink(u, "davInit");
-/*@=boundswrite@*/
-    u = urlFree(u, "urlSplit (davInit)");
-
-    return rc;
-}
-
-/* =============================================================== */
-enum fetch_rtype_e {
-    resr_normal = 0,
-    resr_collection,
-    resr_reference,
-    resr_error
-};
-
-struct fetch_resource_s {
-/*@dependent@*/
-    struct fetch_resource_s *next;
-    char *uri;
-/*@unused@*/
-    char *displayname;
-    enum fetch_rtype_e type;
-    size_t size;
-    time_t modtime;
-    int is_executable;
-    int is_vcr;    /* Is version resource. 0: no vcr, 1 checkin 2 checkout */
-    char *error_reason; /* error string returned for this resource */
-    int error_status; /* error status returned for this resource */
-};
-
-/*@null@*/
-static void *fetch_destroy_item(/*@only@*/ struct fetch_resource_s *res)
-	/*@modifies res @*/
-{
-    ne_free(res->uri);
-    ne_free(res->error_reason);
-    res = _free(res);
-    return NULL;
-}
-
-#ifdef	UNUSED
-/*@null@*/
-static void *fetch_destroy_list(/*@only@*/ struct fetch_resource_s *res)
-	/*@modifies res @*/
-{
-    struct fetch_resource_s *next;
-/*@-branchstate@*/
-    for (; res != NULL; res = next) {
-	next = res->next;
-	res = fetch_destroy_item(res);
-    }
-/*@=branchstate@*/
-    return NULL;
-}
-#endif
-
-#if WITH_NEON_MIN_VERSION >= 0x002600
-static void *fetch_create_item(/*@unused@*/ void *userdata, /*@unused@*/ const ne_uri *uri)
-#else
-static void *fetch_create_item(/*@unused@*/ void *userdata, /*@unused@*/ const char *uri)
-#endif
-        /*@*/
-{
-    struct fetch_resource_s * res = ne_calloc(sizeof(*res));
-    return res;
-}
-
-/* =============================================================== */
-struct fetch_context_s {
-/*@relnull@*/ /*@dependent@*/
-    struct fetch_resource_s **resrock;
-    const char *uri;
-    unsigned int include_target; /* Include resource at href */
-/*@refcounted@*/
-    urlinfo u;
-    int ac;
-    int nalloced;
-    ARGV_t av;
-/*@null@*/ /*@shared@*/
-    struct stat *st;
-    mode_t * modes;
-    size_t * sizes;
-    time_t * mtimes;
-};
-
-/*@null@*/
-static void *fetch_destroy_context(/*@only@*/ /*@null@*/ struct fetch_context_s *ctx)
-	/*@globals internalState @*/
-	/*@modifies ctx, internalState @*/
-{
-    if (ctx == NULL)
-	return NULL;
-    if (ctx->av != NULL)
-	ctx->av = argvFree(ctx->av);
-    ctx->modes = _free(ctx->modes);
-    ctx->sizes = _free(ctx->sizes);
-    ctx->mtimes = _free(ctx->mtimes);
-    ctx->u = urlFree(ctx->u, "fetch_destroy_context");
-    ctx->uri = _free(ctx->uri);
-/*@-boundswrite@*/
-    memset(ctx, 0, sizeof(*ctx));
-/*@=boundswrite@*/
-    ctx = _free(ctx);
-    return NULL;
-}
-
-/*@null@*/
-static void *fetch_create_context(const char *uri, /*@null@*/ struct stat *st)
-	/*@globals internalState @*/
-	/*@modifies internalState @*/
-{
-    struct fetch_context_s * ctx;
-    urlinfo u;
-
-/*@-globs@*/	/* FIX: h_errno annoyance. */
-    if (urlSplit(uri, &u))
-	return NULL;
-/*@=globs@*/
-
-    ctx = ne_calloc(sizeof(*ctx));
-    ctx->uri = xstrdup(uri);
-    ctx->u = urlLink(u, "fetch_create_context");
-    if ((ctx->st = st) != NULL)
-	memset(ctx->st, 0, sizeof(*ctx->st));
-    return ctx;
-}
-
-/*@unchecked@*/ /*@observer@*/
-static const ne_propname fetch_props[] = {
-    { "DAV:", "getcontentlength" },
-    { "DAV:", "getlastmodified" },
-    { "http://apache.org/dav/props/", "executable" },
-    { "DAV:", "resourcetype" },
-    { "DAV:", "checked-in" },
-    { "DAV:", "checked-out" },
-    { NULL, NULL }
-};
-
-#define ELM_resourcetype (NE_PROPS_STATE_TOP + 1)
-#define ELM_collection (NE_PROPS_STATE_TOP + 2)
-
-/*@unchecked@*/ /*@observer@*/
-static const struct ne_xml_idmap fetch_idmap[] = {
-    { "DAV:", "resourcetype", ELM_resourcetype },
-    { "DAV:", "collection", ELM_collection }
-};
-
-static int fetch_startelm(void *userdata, int parent,
-		const char *nspace, const char *name,
-		/*@unused@*/ const char **atts)
-	/*@*/
-{
-    ne_propfind_handler *pfh = userdata;
-    struct fetch_resource_s *r = ne_propfind_current_private(pfh);
-    int state = ne_xml_mapid(fetch_idmap, NE_XML_MAPLEN(fetch_idmap),
-                             nspace, name);
-
-    if (r == NULL ||
-        !((parent == NE_207_STATE_PROP && state == ELM_resourcetype) ||
-          (parent == ELM_resourcetype && state == ELM_collection)))
-        return NE_XML_DECLINE;
-
-    if (state == ELM_collection) {
-	r->type = resr_collection;
-    }
-
-    return state;
-}
-
-static int fetch_compare(const struct fetch_resource_s *r1,
-			    const struct fetch_resource_s *r2)
-	/*@*/
-{
-    /* Sort errors first, then collections, then alphabetically */
-    if (r1->type == resr_error) {
-	return -1;
-    } else if (r2->type == resr_error) {
-	return 1;
-    } else if (r1->type == resr_collection) {
-	if (r2->type != resr_collection) {
-	    return -1;
-	} else {
-	    return strcmp(r1->uri, r2->uri);
-	}
-    } else {
-	if (r2->type != resr_collection) {
-	    return strcmp(r1->uri, r2->uri);
-	} else {
-	    return 1;
-	}
-    }
-}
-
-#if WITH_NEON_MIN_VERSION >= 0x002600
-static void fetch_results(void *userdata, const ne_uri *uarg,
-		    const ne_prop_result_set *set)
-#else
-static void fetch_results(void *userdata, void *uarg,
-		    const ne_prop_result_set *set)
-#endif
-	/*@*/
-{
-    struct fetch_context_s *ctx = userdata;
-    struct fetch_resource_s *current, *previous, *newres;
-    const char *clength, *modtime, *isexec;
-    const char *checkin, *checkout;
-    const ne_status *status = NULL;
-    const char * path = NULL;
-
-#if WITH_NEON_MIN_VERSION >= 0x002600
-    const ne_uri * uri = uarg;
-    (void) urlPath(uri->path, &path);
-#else
-    const char * uri = uarg;
-    (void) urlPath(uri, &path);
-#endif
-    if (path == NULL)
-	return;
-
-    newres = ne_propset_private(set);
-
-if (_dav_debug < 0)
-fprintf(stderr, "==> %s in uri %s\n", path, ctx->uri);
-
-    if (ne_path_compare(ctx->uri, path) == 0 && !ctx->include_target) {
-	/* This is the target URI */
-if (_dav_debug < 0)
-fprintf(stderr, "==> %s skipping target resource.\n", path);
-	/* Free the private structure. */
-/*@-dependenttrans -exposetrans@*/
-	free(newres);
-/*@=dependenttrans =exposetrans@*/
-	return;
-    }
-
-    newres->uri = ne_strdup(path);
-
-/*@-boundsread@*/
-    clength = ne_propset_value(set, &fetch_props[0]);
-    modtime = ne_propset_value(set, &fetch_props[1]);
-    isexec = ne_propset_value(set, &fetch_props[2]);
-    checkin = ne_propset_value(set, &fetch_props[4]);
-    checkout = ne_propset_value(set, &fetch_props[5]);
-/*@=boundsread@*/
-
-/*@-branchstate@*/
-    if (clength == NULL)
-	status = ne_propset_status(set, &fetch_props[0]);
-    if (modtime == NULL)
-	status = ne_propset_status(set, &fetch_props[1]);
-/*@=branchstate@*/
-
-    if (newres->type == resr_normal && status != NULL) {
-	/* It's an error! */
-	newres->error_status = status->code;
-
-	/* Special hack for Apache 1.3/mod_dav */
-	if (strcmp(status->reason_phrase, "status text goes here") == 0) {
-	    const char *desc;
-	    if (status->code == 401) {
-		desc = _("Authorization Required");
-	    } else if (status->klass == 3) {
-		desc = _("Redirect");
-	    } else if (status->klass == 5) {
-		desc = _("Server Error");
-	    } else {
-		desc = _("Unknown Error");
-	    }
-	    newres->error_reason = ne_strdup(desc);
-	} else {
-	    newres->error_reason = ne_strdup(status->reason_phrase);
-	}
-	newres->type = resr_error;
-    }
-
-    if (isexec && strcasecmp(isexec, "T") == 0) {
-	newres->is_executable = 1;
-    } else {
-	newres->is_executable = 0;
-    }
-
-    if (modtime)
-	newres->modtime = ne_httpdate_parse(modtime);
-
-    if (clength)
-	newres->size = atoi(clength);
-
-    /* is vcr */
-    if (checkin) {
-	newres->is_vcr = 1;
-    } else if (checkout) {
-	newres->is_vcr = 2;
-    } else {
-	newres->is_vcr = 0;
-    }
-
-    for (current = *ctx->resrock, previous = NULL; current != NULL;
-	previous = current, current = current->next)
-    {
-	if (fetch_compare(current, newres) >= 0) {
-	    break;
-	}
-    }
-    if (previous) {
-	previous->next = newres;
-    } else {
-/*@-boundswrite -dependenttrans @*/
-	*ctx->resrock = newres;
-/*@=boundswrite =dependenttrans @*/
-    }
-    newres->next = current;
-}
-
-static int davFetch(const urlinfo u, struct fetch_context_s * ctx)
-	/*@globals internalState @*/
-	/*@modifies ctx, internalState @*/
-{
-    const char * path = NULL;
-    int depth = 1;					/* XXX passed arg? */
-    unsigned int include_target = 0;			/* XXX passed arg? */
-    struct fetch_resource_s * resitem = NULL;
-    struct fetch_resource_s ** resrock = &resitem;	/* XXX passed arg? */
-    ne_propfind_handler *pfh;
-    struct fetch_resource_s *current, *next;
-    mode_t st_mode;
-    int rc = 0;
-    int xx;
-
-    (void) urlPath(u->url, &path);
-    pfh = ne_propfind_create(u->sess, ctx->uri, depth);
-
-    /* HACK: need to set RPMURL_SERVER_HASRANGE in u->allow here. */
-
-    ctx->resrock = resrock;
-    ctx->include_target = include_target;
-
-    ne_xml_push_handler(ne_propfind_get_parser(pfh),
-                        fetch_startelm, NULL, NULL, pfh);
-
-    ne_propfind_set_private(pfh, fetch_create_item, NULL);
-
-    rc = ne_propfind_named(pfh, fetch_props, fetch_results, ctx);
-
-    ne_propfind_destroy(pfh);
-
-    for (current = resitem; current != NULL; current = next) {
-	const char *s, *se;
-	char * val;
-
-	next = current->next;
-
-	/* Collections have trailing '/' that needs trim. */
-	/* The top level collection is returned as well. */
-	se = current->uri + strlen(current->uri);
-	if (se[-1] == '/') {
-	    if (strlen(current->uri) <= strlen(path)) {
-		current = fetch_destroy_item(current);
-		continue;
-	    }
-	    se--;
-	}
-	s = se;
-	while (s > current->uri && s[-1] != '/')
-	    s--;
-
-	val = ne_strndup(s, (se - s));
-
-/*@-nullpass@*/
-	val = ne_path_unescape(val);
-/*@=nullpass@*/
-
-	xx = argvAdd(&ctx->av, val);
-if (_dav_debug < 0)
-fprintf(stderr, "*** argvAdd(%p,\"%s\")\n", &ctx->av, val);
-	ne_free(val);
-
-	while (ctx->ac >= ctx->nalloced) {
-	    if (ctx->nalloced <= 0)
-		ctx->nalloced = 1;
-	    ctx->nalloced *= 2;
-	    ctx->modes = xrealloc(ctx->modes,
-				(sizeof(*ctx->modes) * ctx->nalloced));
-	    ctx->sizes = xrealloc(ctx->sizes,
-				(sizeof(*ctx->sizes) * ctx->nalloced));
-	    ctx->mtimes = xrealloc(ctx->mtimes,
-				(sizeof(*ctx->mtimes) * ctx->nalloced));
-	}
-
-	switch (current->type) {
-	case resr_normal:
-	    st_mode = S_IFREG;
-	    /*@switchbreak@*/ break;
-	case resr_collection:
-	    st_mode = S_IFDIR;
-	    /*@switchbreak@*/ break;
-	case resr_reference:
-	case resr_error:
-	default:
-	    st_mode = 0;
-	    /*@switchbreak@*/ break;
-	}
-/*@-boundswrite@*/
-	ctx->modes[ctx->ac] = st_mode;
-	ctx->sizes[ctx->ac] = current->size;
-	ctx->mtimes[ctx->ac] = current->modtime;
-/*@=boundswrite@*/
-	ctx->ac++;
-
-	current = fetch_destroy_item(current);
-    }
-    ctx->resrock = NULL;	/* HACK: avoid leaving stack reference. */
-    /* HACK realloc to truncate modes/sizes/mtimes */
-
-    return rc;
-}
-
-/* HACK this should be rewritten to use davReq/davResp w callbacks. */
-static int davHEAD(urlinfo u, struct stat *st) 
-	/*@modifies *st @*/
-{
-    ne_request *req;
-    const char *htag;
-    const char *value = NULL;
-    int rc;
-
-    st->st_mode = S_IFREG;
-    st->st_blksize = 4 * 1024;	/* HACK correct for linux ext */
-    st->st_size = -1;
-    st->st_atime = -1;
-    st->st_mtime = -1;
-    st->st_ctime = -1;
-
-    req = ne_request_create(u->sess, "HEAD", u->url);
-
-    rc = ne_request_dispatch(req);
-    switch (rc) {
-    default:
-	goto exit;
-	/*@notreached@*/
-    case NE_OK:
-	if (ne_get_status(req)->klass != 2) {
-	    rc = NE_ERROR;
-	    goto exit;
-	}
-	break;
-    }
-
-#ifdef	NOTYET
-    htag = "ETag";
-    value = ne_get_response_header(req, htag); 
-    if (value) {
-	/* inode-size-mtime */
-    }
-#endif
-
-    htag = "Content-Length";
-#if defined(HAVE_NEON_NE_GET_RESPONSE_HEADER)
-    value = ne_get_response_header(req, htag); 
-#endif
-    if (value) {
-	st->st_size = strtoll(value, NULL, 10);
-	st->st_blocks = (st->st_size + 511)/512;
-    }
-
-    htag = "Last-Modified";
-#if defined(HAVE_NEON_NE_GET_RESPONSE_HEADER)
-    value = ne_get_response_header(req, htag); 
-#endif
-    if (value) {
-	st->st_mtime = ne_httpdate_parse(value);
-	st->st_atime = st->st_ctime = st->st_mtime;	/* HACK */
-    }
-
-exit:
-    ne_request_destroy(req);
-    return rc;
-}
-
-static int davNLST(struct fetch_context_s * ctx)
-	/*@globals internalState @*/
-	/*@modifies ctx, internalState @*/
-{
-    urlinfo u = NULL;
-    int rc;
-    int xx;
-
-    rc = davInit(ctx->uri, &u);
-    if (rc || u == NULL)
-	goto exit;
-
-/* HACK do PROPFIND through davFetch iff enabled, otherwise HEAD Content-length/ETag/Last-Modified */
-    if (u->allow & RPMURL_SERVER_HASDAV)
-	   rc = davFetch(u, ctx);	/* use PROPFIND to get contentLength */
-    else
-	   rc = davHEAD(u, ctx->st);	/* use HEAD to get contentLength */
-
-    switch (rc) {
-    case NE_OK:
-        break;
-    case NE_ERROR:
-	/* HACK: "405 Method Not Allowed" for PROPFIND on non-DAV servers. */
-	/* XXX #206066 OPTIONS is ok, but PROPFIND from Stat() fails. */
-	/* rpm -qp --rpmiodebug --davdebug http://people.freedesktop.org/~sandmann/metacity-2.16.0-2.fc6/i386/metacity-2.16.0-2.fc6.i386.rpm */
-	/* HACK: "301 Moved Permanently" on empty subdir. */
-	if (!strncmp("301 ", ne_get_error(u->sess), sizeof("301 ")-1))
-	    break;
-	/*@fallthrough@*/
-    default:
-if (_dav_debug)
-fprintf(stderr, "*** Fetch from %s:%d failed:\n\t%s\n",
-		   u->host, u->port, ne_get_error(u->sess));
-        break;
-    }
-
-exit:
-    xx = davFree(u);
-    return rc;
-}
-
-/* =============================================================== */
-static int my_result(const char * msg, int ret, /*@null@*/ FILE * fp)
-	/*@modifies *fp @*/
-{
-    /* HACK: don't print unless debugging. */
-    if (_dav_debug >= 0)
-	return ret;
-    if (fp == NULL)
-	fp = stderr;
-    if (msg != NULL)
-	fprintf(fp, "*** %s: ", msg);
-
-    /* HACK FTPERR_NE_FOO == -NE_FOO error impedance match */
-#ifdef	HACK
-    fprintf(fp, "%s: %s\n", ftpStrerror(-ret), ne_get_error(sess));
-#else
-    fprintf(fp, "%s\n", ftpStrerror(-ret));
-#endif
-    return ret;
-}
-
-#ifdef	DYING
-static void hexdump(const unsigned char * buf, ssize_t len)
-	/*@*/
-{
-    int i;
-    if (len <= 0)
-	return;
-    for (i = 0; i < len; i++) {
-	if (i != 0 && (i%16) == 0)
-	    fprintf(stderr, "\n");
-	fprintf(stderr, " %02X", buf[i]);
-    }
-    fprintf(stderr, "\n");
-}
-#endif
-
-/*@-mustmod@*/
-static void davAcceptRanges(void * userdata, /*@null@*/ const char * value)
-	/*@modifies userdata @*/
-{
-    urlinfo u = userdata;
-
-    if (!(u != NULL && value != NULL)) return;
-if (_dav_debug < 0)
-fprintf(stderr, "*** u %p Accept-Ranges: %s\n", u, value);
-    if (!strcmp(value, "bytes"))
-	u->allow |= RPMURL_SERVER_HASRANGE;
-    if (!strcmp(value, "none"))
-	u->allow &= ~RPMURL_SERVER_HASRANGE;
-}
-/*@=mustmod@*/
-
-#if !defined(HAVE_NEON_NE_GET_RESPONSE_HEADER)
-static void davAllHeaders(void * userdata, const char * value)
-{
-    FD_t ctrl = userdata;
-
-    if (!(ctrl != NULL && value != NULL)) return;
-if (_dav_debug)
-fprintf(stderr, "<- %s\n", value);
-}
-#endif
-
-/*@-mustmod@*/
-static void davContentLength(void * userdata, /*@null@*/ const char * value)
-	/*@modifies userdata @*/
-{
-    FD_t ctrl = userdata;
-
-    if (!(ctrl != NULL && value != NULL)) return;
-if (_dav_debug < 0)
-fprintf(stderr, "*** fd %p Content-Length: %s\n", ctrl, value);
-/*@-unrecog@*/
-   ctrl->contentLength = strtoll(value, NULL, 10);
-/*@=unrecog@*/
-}
-/*@=mustmod@*/
-
-/*@-mustmod@*/
-static void davConnection(void * userdata, /*@null@*/ const char * value)
-	/*@modifies userdata @*/
-{
-    FD_t ctrl = userdata;
-
-    if (!(ctrl != NULL && value != NULL)) return;
-if (_dav_debug < 0)
-fprintf(stderr, "*** fd %p Connection: %s\n", ctrl, value);
-    if (!strcasecmp(value, "close"))
-	ctrl->persist = 0;
-    else if (!strcasecmp(value, "Keep-Alive"))
-	ctrl->persist = 1;
-}
-/*@=mustmod@*/
-
-/*@-mustmod@*/ /* HACK: stash error in *str. */
-int davResp(urlinfo u, FD_t ctrl, /*@unused@*/ char *const * str)
-{
-    int rc = 0;
-
-    rc = ne_begin_request(ctrl->req);
-    rc = my_result("ne_begin_req(ctrl->req)", rc, NULL);
-
-if (_dav_debug < 0)
-fprintf(stderr, "*** davResp(%p,%p,%p) sess %p req %p rc %d\n", u, ctrl, str, u->sess, ctrl->req, rc);
-
-    /* HACK FTPERR_NE_FOO == -NE_FOO error impedance match */
-/*@-observertrans@*/
-    if (rc)
-	fdSetSyserrno(ctrl, errno, ftpStrerror(-rc));
-/*@=observertrans@*/
-
-    return rc;
-}
-/*@=mustmod@*/
-
-int davReq(FD_t ctrl, const char * httpCmd, const char * httpArg)
-{
-    urlinfo u;
-    int rc = 0;
-
-assert(ctrl != NULL);
-    u = ctrl->url;
-    URLSANE(u);
-
-if (_dav_debug < 0)
-fprintf(stderr, "*** davReq(%p,%s,\"%s\") entry sess %p req %p\n", ctrl, httpCmd, (httpArg ? httpArg : ""), u->sess, ctrl->req);
-
-    ctrl->persist = (u->httpVersion > 0 ? 1 : 0);
-    ctrl = fdLink(ctrl, "open ctrl (davReq)");
-
-assert(u->sess != NULL);
-assert(ctrl->req == NULL);
-/*@-nullpass@*/
-    ctrl->req = ne_request_create(u->sess, httpCmd, httpArg);
-/*@=nullpass@*/
-assert(ctrl->req != NULL);
-
-    ne_set_request_private(ctrl->req, "fd", ctrl);
-
-#if !defined(HAVE_NEON_NE_GET_RESPONSE_HEADER)
-    ne_add_response_header_catcher(ctrl->req, davAllHeaders, ctrl);
-
-    ne_add_response_header_handler(ctrl->req, "Content-Length",
-		davContentLength, ctrl);
-    ne_add_response_header_handler(ctrl->req, "Connection",
-		davConnection, ctrl);
-#endif
-
-    if (!strcmp(httpCmd, "PUT")) {
-#if defined(HAVE_NEON_NE_SEND_REQUEST_CHUNK)
-	ctrl->wr_chunked = 1;
-	ne_add_request_header(ctrl->req, "Transfer-Encoding", "chunked");
-	ne_set_request_chunked(ctrl->req, 1);
-	/* HACK: no retries if/when chunking. */
-	rc = davResp(u, ctrl, NULL);
-#else
-	rc = FTPERR_SERVER_IO_ERROR;
-#endif
-    } else {
-	/* HACK: possible Last-Modified: Tue, 02 Nov 2004 14:29:36 GMT */
-	/* HACK: possible ETag: "inode-size-mtime" */
-#if !defined(HAVE_NEON_NE_GET_RESPONSE_HEADER)
-	ne_add_response_header_handler(ctrl->req, "Accept-Ranges",
-			davAcceptRanges, u);
-#endif
-	/* HACK: possible Transfer-Encoding: on GET. */
-
-	/* HACK: other errors may need retry too. */
-	/* HACK: neon retries once, gud enuf. */
-	/* HACK: retry counter? */
-	do {
-	    rc = davResp(u, ctrl, NULL);
-	} while (rc == NE_RETRY);
-    }
-    if (rc)
-	goto errxit;
-
-if (_dav_debug < 0)
-fprintf(stderr, "*** davReq(%p,%s,\"%s\") exit sess %p req %p rc %d\n", ctrl, httpCmd, (httpArg ? httpArg : ""), u->sess, ctrl->req, rc);
-
-#if defined(HAVE_NEON_NE_GET_RESPONSE_HEADER)
-    davContentLength(ctrl,
-		ne_get_response_header(ctrl->req, "Content-Length"));
-    davConnection(ctrl,
-		ne_get_response_header(ctrl->req, "Connection"));
-    if (strcmp(httpCmd, "PUT"))
-	davAcceptRanges(u,
-		ne_get_response_header(ctrl->req, "Accept-Ranges"));
-#endif
-
-    ctrl = fdLink(ctrl, "open data (davReq)");
-    return 0;
-
-errxit:
-/*@-observertrans@*/
-    fdSetSyserrno(ctrl, errno, ftpStrerror(rc));
-/*@=observertrans@*/
-
-    /* HACK balance fd refs. ne_session_destroy to tear down non-keepalive? */
-    ctrl = fdLink(ctrl, "error data (davReq)");
-
-    return rc;
-}
-
-FD_t davOpen(const char * url, /*@unused@*/ int flags,
-		/*@unused@*/ mode_t mode, /*@out@*/ urlinfo * uret)
-{
-    const char * path = NULL;
-    urltype urlType = urlPath(url, &path);
-    urlinfo u = NULL;
-    FD_t fd = NULL;
-    int rc;
-
-#if 0	/* XXX makeTempFile() heartburn */
-    assert(!(flags & O_RDWR));
-#endif
-
-if (_dav_debug < 0)
-fprintf(stderr, "*** davOpen(%s,0x%x,0%o,%p)\n", url, flags, mode, uret);
-    rc = davInit(url, &u);
-    if (rc || u == NULL || u->sess == NULL)
-	goto exit;
-
-    if (u->ctrl == NULL)
-	u->ctrl = fdNew("persist ctrl (davOpen)");
-    if (u->ctrl->nrefs > 2 && u->data == NULL)
-	u->data = fdNew("persist data (davOpen)");
-
-    if (u->ctrl->url == NULL)
-	fd = fdLink(u->ctrl, "grab ctrl (davOpen persist ctrl)");
-    else if (u->data->url == NULL)
-	fd = fdLink(u->data, "grab ctrl (davOpen persist data)");
-    else
-	fd = fdNew("grab ctrl (davOpen)");
-
-    if (fd) {
-	fdSetOpen(fd, url, flags, mode);
-	fdSetIo(fd, ufdio);
-
-	fd->ftpFileDoneNeeded = 0;
-	fd->rd_timeoutsecs = httpTimeoutSecs;
-	fd->contentLength = fd->bytesRemain = -1;
-	fd->url = urlLink(u, "url (davOpen)");
-	fd = fdLink(fd, "grab data (davOpen)");
-assert(urlType == URL_IS_HTTPS || urlType == URL_IS_HTTP || urlType == URL_IS_HKP);
-	fd->urlType = urlType;
-    }
-
-exit:
-/*@-boundswrite@*/
-    if (uret)
-	*uret = u;
-/*@=boundswrite@*/
-    /*@-refcounttrans@*/
-    return fd;
-    /*@=refcounttrans@*/
-}
-
-ssize_t davRead(void * cookie, /*@out@*/ char * buf, size_t count)
-{
-    FD_t fd = cookie;
-    ssize_t rc;
-
-#if 0
-assert(count >= 128);	/* HACK: see ne_request.h comment */
-#endif
-    rc = ne_read_response_block(fd->req, buf, count);
-
-if (_dav_debug < 0) {
-fprintf(stderr, "*** davRead(%p,%p,0x%x) rc 0x%x\n", cookie, buf, (unsigned)count, (unsigned)rc);
-#ifdef	DYING
-hexdump(buf, rc);
-#endif
-    }
-
-    return rc;
-}
-
-ssize_t davWrite(void * cookie, const char * buf, size_t count)
-{
-#if !defined(NEONBLOWSCHUNKS) || defined(HAVE_NEON_NE_SEND_REQUEST_CHUNK) || defined(__LCLINT__)
-    FD_t fd = cookie;
-#endif
-    ssize_t rc;
-    int xx = -1;
-
-#if !defined(NEONBLOWSCHUNKS)
-    ne_session * sess;
-
-assert(fd->req != NULL);
-    sess = ne_get_session(fd->req);
-assert(sess != NULL);
-
-    /* HACK: include ne_private.h to access sess->socket for now. */
-    xx = ne_sock_fullwrite(sess->socket, buf, count);
-#else
-#if defined(HAVE_NEON_NE_SEND_REQUEST_CHUNK) || defined(__LCLINT__)
-assert(fd->req != NULL);
-    xx = ne_send_request_chunk(fd->req, buf, count);
-#else
-    errno = EIO;       /* HACK */
-    return -1;
-#endif
-#endif
-
-    /* HACK: stupid error impedence matching. */
-    rc = (xx == 0 ? count : -1);
-
-if (_dav_debug < 0)
-fprintf(stderr, "*** davWrite(%p,%p,0x%x) rc 0x%x\n", cookie, buf, (unsigned)count, (unsigned)rc);
-#ifdef	DYING
-if (count > 0)
-hexdump(buf, count);
-#endif
-
-    return rc;
-}
-
-int davSeek(void * cookie, /*@unused@*/ _libio_pos_t pos, int whence)
-{
-if (_dav_debug < 0)
-fprintf(stderr, "*** davSeek(%p,pos,%d)\n", cookie, whence);
-    return -1;
-}
-
-/*@-mustmod@*/	/* HACK: fd->req is modified. */
-int davClose(void * cookie)
-{
-/*@-onlytrans@*/
-    FD_t fd = cookie;
-/*@=onlytrans@*/
-    int rc;
-
-assert(fd->req != NULL);
-    rc = ne_end_request(fd->req);
-    rc = my_result("ne_end_request(req)", rc, NULL);
-
-    ne_request_destroy(fd->req);
-    fd->req = NULL;
-
-if (_dav_debug < 0)
-fprintf(stderr, "*** davClose(%p) rc %d\n", fd, rc);
-    return rc;
-}
-/*@=mustmod@*/
-
-/* =============================================================== */
-int davMkdir(const char * path, mode_t mode)
-{
-    urlinfo u = NULL;
-    const char * src = NULL;
-    int rc;
-
-    rc = davInit(path, &u);
-    if (rc)
-	goto exit;
-
-    (void) urlPath(path, &src);
-
-    rc = ne_mkcol(u->sess, path);
-
-    if (rc) rc = -1;	/* XXX HACK: errno impedance match */
-
-    /* XXX HACK: verify getrestype(remote) == resr_collection */
-
-exit:
-if (_dav_debug)
-fprintf(stderr, "*** davMkdir(%s,0%o) rc %d\n", path, mode, rc);
-    return rc;
-}
-
-int davRmdir(const char * path)
-{
-    urlinfo u = NULL;
-    const char * src = NULL;
-    int rc;
-
-    rc = davInit(path, &u);
-    if (rc)
-	goto exit;
-
-    (void) urlPath(path, &src);
-
-    /* XXX HACK: only getrestype(remote) == resr_collection */
-
-    rc = ne_delete(u->sess, path);
-
-    if (rc) rc = -1;	/* XXX HACK: errno impedance match */
-
-exit:
-if (_dav_debug)
-fprintf(stderr, "*** davRmdir(%s) rc %d\n", path, rc);
-    return rc;
-}
-
-int davRename(const char * oldpath, const char * newpath)
-{
-    urlinfo u = NULL;
-    const char * src = NULL;
-    const char * dst = NULL;
-    int overwrite = 1;		/* HACK: set this correctly. */
-    int rc;
-
-    rc = davInit(oldpath, &u);
-    if (rc)
-	goto exit;
-
-    (void) urlPath(oldpath, &src);
-    (void) urlPath(newpath, &dst);
-
-    /* XXX HACK: only getrestype(remote) != resr_collection */
-
-    rc = ne_move(u->sess, overwrite, src, dst);
-
-    if (rc) rc = -1;	/* XXX HACK: errno impedance match */
-
-exit:
-if (_dav_debug)
-fprintf(stderr, "*** davRename(%s,%s) rc %d\n", oldpath, newpath, rc);
-    return rc;
-}
-
-int davUnlink(const char * path)
-{
-    urlinfo u = NULL;
-    const char * src = NULL;
-    int rc;
-
-    rc = davInit(path, &u);
-    if (rc)
-	goto exit;
-
-    (void) urlPath(path, &src);
-
-    /* XXX HACK: only getrestype(remote) != resr_collection */
-
-    rc = ne_delete(u->sess, src);
-
-exit:
-    if (rc) rc = -1;	/* XXX HACK: errno impedance match */
-
-if (_dav_debug)
-fprintf(stderr, "*** davUnlink(%s) rc %d\n", path, rc);
-    return rc;
-}
-
-#ifdef	NOTYET
-static int davChdir(const char * path)
-	/*@globals h_errno, fileSystem, internalState @*/
-	/*@modifies fileSystem, internalState @*/
-{
-    return davCommand("CWD", path, NULL);
-}
-#endif	/* NOTYET */
-
-/* =============================================================== */
-
-static const char * statstr(const struct stat * st,
-		/*@returned@*/ /*@out@*/ char * buf)
-	/*@modifies *buf @*/
-{
-    sprintf(buf,
-	"*** dev %x ino %x mode %0o nlink %d uid %d gid %d rdev %x size %x\n",
-	(unsigned)st->st_dev,
-	(unsigned)st->st_ino,
-	st->st_mode,
-	(unsigned)st->st_nlink,
-	st->st_uid,
-	st->st_gid,
-	(unsigned)st->st_rdev,
-	(unsigned)st->st_size);
-    return buf;
-}
-
-/*@unchecked@*/
-static unsigned int dav_st_ino = 0xdead0000;
-
-/*@-boundswrite@*/
-int davStat(const char * path, /*@out@*/ struct stat *st)
-	/*@globals dav_st_ino, fileSystem, internalState @*/
-	/*@modifies *st, dav_st_ino, fileSystem, internalState @*/
-{
-    struct fetch_context_s * ctx = NULL;
-    char buf[1024];
-    int rc = -1;
-
-/* HACK: neon really wants collections with trailing '/' */
-    ctx = fetch_create_context(path, st);
-    if (ctx == NULL) {
-fprintf(stderr, "==> %s fetch_create_context ctx %p\n", "davStat", ctx);
-/* HACK: errno = ??? */
-	goto exit;
-    }
-    rc = davNLST(ctx);
-    if (rc) {
-/* HACK: errno = ??? */
-	goto exit;
-    }
-
-    if (st->st_mode == 0)
-	st->st_mode = (ctx->ac > 1 ? S_IFDIR : S_IFREG);
-    st->st_size = (ctx->sizes ? ctx->sizes[0] : st->st_size);
-    st->st_mtime = (ctx->mtimes ? ctx->mtimes[0] : st->st_mtime);
-    st->st_atime = st->st_ctime = st->st_mtime;	/* HACK */
-    if (S_ISDIR(st->st_mode)) {
-	st->st_nlink = 2;
-	st->st_mode |= 0755;
-    } else
-    if (S_ISREG(st->st_mode)) {
-	st->st_nlink = 1;
-	st->st_mode |= 0644;
-    }
-
-    /* XXX fts(3) needs/uses st_ino, make something up for now. */
-    if (st->st_ino == 0)
-	st->st_ino = dav_st_ino++;
-
-exit:
-if (_dav_debug < 0)
-fprintf(stderr, "*** davStat(%s) rc %d\n%s", path, rc, statstr(st, buf));
-    ctx = fetch_destroy_context(ctx);
-    return rc;
-}
-/*@=boundswrite@*/
-
-/*@-boundswrite@*/
-int davLstat(const char * path, /*@out@*/ struct stat *st)
-	/*@globals dav_st_ino, fileSystem, internalState @*/
-	/*@modifies *st, dav_st_ino, fileSystem, internalState @*/
-{
-    struct fetch_context_s * ctx = NULL;
-    char buf[1024];
-    int rc = -1;
-
-/* HACK: neon really wants collections with trailing '/' */
-    ctx = fetch_create_context(path, st);
-    if (ctx == NULL) {
-/* HACK: errno = ??? */
-	goto exit;
-    }
-    rc = davNLST(ctx);
-    if (rc) {
-/* HACK: errno = ??? */
-	goto exit;
-    }
-
-    if (st->st_mode == 0)
-	st->st_mode = (ctx->ac > 1 ? S_IFDIR : S_IFREG);
-    st->st_size = (ctx->sizes ? ctx->sizes[0] : st->st_size);
-    st->st_mtime = (ctx->mtimes ? ctx->mtimes[0] : st->st_mtime);
-    st->st_atime = st->st_ctime = st->st_mtime;	/* HACK */
-    if (S_ISDIR(st->st_mode)) {
-	st->st_nlink = 2;
-	st->st_mode |= 0755;
-    } else
-    if (S_ISREG(st->st_mode)) {
-	st->st_nlink = 1;
-	st->st_mode |= 0644;
-    }
-
-    /* XXX fts(3) needs/uses st_ino, make something up for now. */
-    if (st->st_ino == 0)
-	st->st_ino = dav_st_ino++;
-if (_dav_debug < 0)
-fprintf(stderr, "*** davLstat(%s) rc %d\n%s\n", path, rc, statstr(st, buf));
-exit:
-    ctx = fetch_destroy_context(ctx);
-    return rc;
-}
-/*@=boundswrite@*/
-
-#ifdef	NOTYET
-static int davReadlink(const char * path, /*@out@*/ char * buf, size_t bufsiz)
-	/*@globals h_errno, fileSystem, internalState @*/
-	/*@modifies *buf, fileSystem, internalState @*/
-{
-    int rc;
-    rc = davNLST(path, DO_FTP_READLINK, NULL, buf, bufsiz);
-if (_dav_debug < 0)
-fprintf(stderr, "*** davReadlink(%s) rc %d\n", path, rc);
-    return rc;
-}
-#endif	/* NOTYET */
-
 /* =============================================================== */
 /*@unchecked@*/
 int avmagicdir = 0x3607113;
@@ -1660,179 +145,3 @@
 /*@=kepttrans@*/
 }
 /*@=boundswrite@*/
-
-/* =============================================================== */
-/*@unchecked@*/
-int davmagicdir = 0x8440291;
-
-int davClosedir(/*@only@*/ DIR * dir)
-{
-    DAVDIR avdir = (DAVDIR)dir;
-
-if (_dav_debug < 0)
-fprintf(stderr, "*** davClosedir(%p)\n", avdir);
-
-#if defined(HAVE_PTHREAD_H)
-/*@-moduncon -noeffectuncon @*/
-    (void) pthread_mutex_destroy(&avdir->lock);
-/*@=moduncon =noeffectuncon @*/
-#endif
-
-    avdir = _free(avdir);
-    return 0;
-}
-
-struct dirent * davReaddir(DIR * dir)
-{
-    DAVDIR avdir = (DAVDIR)dir;
-    struct dirent * dp;
-    const char ** av;
-    unsigned char * dt;
-    int ac;
-    int i;
-
-    if (avdir == NULL || !ISDAVMAGIC(avdir) || avdir->data == NULL) {
-	/* XXX TODO: EBADF errno. */
-	return NULL;
-    }
-
-    dp = (struct dirent *) avdir->data;
-    av = (const char **) (dp + 1);
-    ac = avdir->size;
-    dt = (unsigned char *) (av + (ac + 1));
-    i = avdir->offset + 1;
-
-/*@-boundsread@*/
-    if (i < 0 || i >= ac || av[i] == NULL)
-	return NULL;
-/*@=boundsread@*/
-
-    avdir->offset = i;
-
-    /* XXX glob(3) uses REAL_DIR_ENTRY(dp) test on d_ino */
-/*@-type@*/
-    dp->d_ino = i + 1;		/* W2DO? */
-    dp->d_reclen = 0;		/* W2DO? */
-
-#if !(defined(hpux) || defined(__hpux) || defined(sun))
-#if !defined(__APPLE__) && !defined(__FreeBSD_kernel__) && !defined(__FreeBSD__)
-    dp->d_off = 0;		/* W2DO? */
-#endif
-/*@-boundsread@*/
-    dp->d_type = dt[i];
-/*@=boundsread@*/
-#endif
-/*@=type@*/
-
-    strncpy(dp->d_name, av[i], sizeof(dp->d_name));
-if (_dav_debug < 0)
-fprintf(stderr, "*** davReaddir(%p) %p \"%s\"\n", (void *)avdir, dp, dp->d_name);
-
-    return dp;
-}
-
-/*@-boundswrite@*/
-DIR * davOpendir(const char * path)
-{
-    struct fetch_context_s * ctx;
-    DAVDIR avdir;
-    struct dirent * dp;
-    size_t nb;
-    const char ** av, ** nav;
-    unsigned char * dt;
-    char * t;
-    int ac, nac;
-    int rc;
-
-    /* HACK: glob does not pass dirs with trailing '/' */
-    nb = strlen(path)+1;
-/*@-branchstate@*/
-    if (path[nb-1] != '/') {
-	char * npath = alloca(nb+1);
-	*npath = '\0';
-	(void) stpcpy( stpcpy(npath, path), "/");
-	path = npath;
-    }
-/*@=branchstate@*/
-
-if (_dav_debug < 0)
-fprintf(stderr, "*** davOpendir(%s)\n", path);
-
-    /* Load DAV collection into argv. */
-    ctx = fetch_create_context(path, NULL);
-    if (ctx == NULL) {
-/* HACK: errno = ??? */
-	return NULL;
-    }
-    rc = davNLST(ctx);
-    if (rc) {
-/* HACK: errno = ??? */
-	return NULL;
-    }
-
-    nb = 0;
-    ac = 0;
-    av = ctx->av;
-    if (av != NULL)
-    while (av[ac] != NULL)
-	nb += strlen(av[ac++]) + 1;
-    ac += 2;	/* for "." and ".." */
-    nb += sizeof(".") + sizeof("..");
-
-    nb += sizeof(*avdir) + sizeof(*dp) + ((ac + 1) * sizeof(*av)) + (ac + 1);
-    avdir = xcalloc(1, nb);
-    /*@-abstract@*/
-    dp = (struct dirent *) (avdir + 1);
-    nav = (const char **) (dp + 1);
-    dt = (unsigned char *) (nav + (ac + 1));
-    t = (char *) (dt + ac + 1);
-    /*@=abstract@*/
-
-    avdir->fd = davmagicdir;
-/*@-usereleased@*/
-    avdir->data = (char *) dp;
-/*@=usereleased@*/
-    avdir->allocation = nb;
-    avdir->size = ac;
-    avdir->offset = -1;
-    avdir->filepos = 0;
-
-#if defined(HAVE_PTHREAD_H)
-/*@-moduncon -noeffectuncon -nullpass @*/
-    (void) pthread_mutex_init(&avdir->lock, NULL);
-/*@=moduncon =noeffectuncon =nullpass @*/
-#endif
-
-    nac = 0;
-/*@-dependenttrans -unrecog@*/
-    dt[nac] = DT_DIR;	nav[nac++] = t;	t = stpcpy(t, ".");	t++;
-    dt[nac] = DT_DIR;	nav[nac++] = t;	t = stpcpy(t, "..");	t++;
-/*@=dependenttrans =unrecog@*/
-
-    /* Copy DAV items into DIR elments. */
-    ac = 0;
-    if (av != NULL)
-    while (av[ac] != NULL) {
-	nav[nac] = t;
-	dt[nac] = (S_ISDIR(ctx->modes[ac]) ? DT_DIR : DT_REG);
-	t = stpcpy(t, av[ac]);
-	ac++;
-	t++;
-	nac++;
-    }
-    nav[nac] = NULL;
-
-    ctx = fetch_destroy_context(ctx);
-
-/*@-kepttrans@*/
-    return (DIR *) avdir;
-/*@=kepttrans@*/
-}
-/*@=modfilesys@*/
-
-char * davRealpath(const char * path, char * resolved_path)
-{
-assert(resolved_path == NULL);        /* XXX no POSIXly broken realpath(3) here. */
-    /* XXX TODO: handle redirects. For now, just dupe the path. */
-    return xstrdup(path);
-}
--- rpm-4.5/rpmio/rpmdav.h	2007-05-25 20:36:36.000000000 +0300
+++ rpm-4.4.9/rpmio/rpmdav.h	2008-09-04 17:21:50.369579599 +0300
@@ -46,12 +46,6 @@
 extern int avmagicdir;
 #define ISAVMAGIC(_dir) (!memcmp((_dir), &avmagicdir, sizeof(avmagicdir)))
 
-/**
- */
-/*@unchecked@*/
-extern int davmagicdir;
-#define ISDAVMAGIC(_dir) (!memcmp((_dir), &davmagicdir, sizeof(davmagicdir)))
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -85,133 +79,6 @@
 	/*@globals fileSystem, internalState @*/
 	/*@modifies fileSystem, internalState @*/;
 
-/**
- * Send a http request.
- * @param ctrl		
- * @param httpCmd	http command
- * @param httpArg	http command argument (NULL if none)
- * @returns		0 on success
- */
-int davReq(FD_t ctrl, const char * httpCmd, /*@null@*/ const char * httpArg)
-	/*@globals fileSystem, internalState @*/
-	/*@modifies ctrl, fileSystem, internalState @*/;
-
-/**
- * Read a http response.
- * @param u
- * @param cntl		
- * @retval *str		error msg		
- * @returns		0 on success
- */
-/*@-exportlocal@*/
-int davResp(urlinfo u, FD_t ctrl, /*@out@*/ /*@null@*/ char *const * str)
-	/*@globals fileSystem, internalState @*/
-	/*@modifies ctrl, *str, fileSystem, internalState @*/;
-/*@=exportlocal@*/
-
-/**
- */
-/*@null@*/
-FD_t davOpen(const char * url, /*@unused@*/ int flags,
-		/*@unused@*/ mode_t mode, /*@out@*/ urlinfo * uret)
-        /*@globals internalState @*/
-        /*@modifies *uret, internalState @*/;
-
-/**
- */
-/*@-incondefs@*/
-ssize_t davRead(void * cookie, /*@out@*/ char * buf, size_t count)
-        /*@globals fileSystem, internalState @*/
-        /*@modifies buf, fileSystem, internalState @*/
-	/*@requires maxSet(buf) >= (count - 1) @*/
-	/*@ensures maxRead(buf) == result @*/;
-/*@=incondefs@*/
-
-/**
- */
-ssize_t davWrite(void * cookie, const char * buf, size_t count)
-        /*@globals fileSystem, internalState @*/
-        /*@modifies fileSystem, internalState @*/;
-
-/**
- */
-int davSeek(void * cookie, _libio_pos_t pos, int whence)
-        /*@globals fileSystem, internalState @*/
-        /*@modifies fileSystem, internalState @*/;
-
-/**
- */
-int davClose(void * cookie)
-	/*@globals fileSystem, internalState @*/
-	/*@modifies cookie, fileSystem, internalState @*/;
-
-/**
- */
-int davMkdir(const char * path, mode_t mode)
-	/*@globals fileSystem, internalState @*/
-	/*@modifies fileSystem, internalState @*/;
-
-/**
- */
-int davRmdir(const char * path)
-	/*@globals fileSystem, internalState @*/
-	/*@modifies fileSystem, internalState @*/;
-
-/**
- */
-int davRename(const char * oldpath, const char * newpath)
-	/*@globals fileSystem, internalState @*/
-	/*@modifies fileSystem, internalState @*/;
-
-/**
- */
-int davUnlink(const char * path)
-	/*@globals fileSystem, internalState @*/
-	/*@modifies fileSystem, internalState @*/;
-
-/**
- * Close a DAV collection.
- * @param dir		argv DIR
- * @return 		0 always
- */
-int davClosedir(/*@only@*/ DIR * dir)
-	/*@globals fileSystem @*/
-	/*@modifies dir, fileSystem @*/;
-
-/**
- * Return next entry from a DAV collection.
- * @param dir		argv DIR
- * @return 		next entry
- */
-/*@dependent@*/ /*@null@*/
-struct dirent * davReaddir(DIR * dir)
-	/*@globals fileSystem @*/
-	/*@modifies fileSystem @*/;
-
-/**
- * Create an argv directory from DAV collection.
- * @param path		URL for DAV collection path
- * @return 		argv DIR
- */
-/*@null@*/
-DIR * davOpendir(const char * path)
-	/*@globals fileSystem, internalState @*/
-	/*@modifies fileSystem, internalState @*/;
-
-/**
- * stat(2) clone.
- */
-int davStat(const char * path, /*@out@*/ struct stat * st)
-	/*@globals fileSystem, internalState @*/
-	/*@modifies *st, fileSystem, internalState @*/;
-
-/**
- * lstat(2) clone.
- */
-int davLstat(const char * path, /*@out@*/ struct stat * st)
-	/*@globals fileSystem, internalState @*/
-	/*@modifies *st, fileSystem, internalState @*/;
-
 #ifdef __cplusplus
 }
 #endif
--- rpm-4.5/rpmio/rpmio.c	2008-09-04 18:04:37.362241187 +0300
+++ rpm-4.5/rpmio/rpmio.c	2008-09-04 18:05:08.695569896 +0300
@@ -155,11 +155,6 @@
 /*@unchecked@*/
 int _ftp_debug = 0;
 
-/**
- */
-/*@unchecked@*/
-int _dav_debug = 0;
-
 /* =============================================================== */
 
 /*@-boundswrite@*/
@@ -386,13 +381,6 @@
 
     fdstat_enter(fd, FDSTAT_READ);
 /*@-boundswrite@*/
-    /* HACK: flimsy wiring for davRead */
-    if (fd->req != NULL) {
-	rc = davRead(fd, buf, (count > fd->bytesRemain ? fd->bytesRemain : count));
-	/* XXX Chunked davRead EOF. */
-	if (rc == 0)
-	    fd->bytesRemain = 0;
-    } else
 	rc = read(fdFileno(fd), buf, (count > fd->bytesRemain ? fd->bytesRemain : count));
 /*@=boundswrite@*/
     fdstat_exit(fd, FDSTAT_READ, rc);
@@ -420,10 +408,6 @@
 
     fdstat_enter(fd, FDSTAT_WRITE);
 /*@-boundsread@*/
-    /* HACK: flimsy wiring for davWrite */
-    if (fd->req != NULL)
-	rc = davWrite(fd, buf, (count > fd->bytesRemain ? fd->bytesRemain : count));
-    else
 	rc = write(fdno, buf, (count > fd->bytesRemain ? fd->bytesRemain : count));
 /*@=boundsread@*/
     fdstat_exit(fd, FDSTAT_WRITE, rc);
@@ -470,11 +454,6 @@
     fdSetFdno(fd, -1);
 
     fdstat_enter(fd, FDSTAT_CLOSE);
-    /* HACK: flimsy wiring for davClose */
-/*@-branchstate@*/
-    if (fd->req != NULL)
-	rc = davClose(fd);
-    else
 	rc = ((fdno >= 0) ? close(fdno) : -2);
 /*@=branchstate@*/
     fdstat_exit(fd, FDSTAT_CLOSE, rc);
@@ -544,10 +523,6 @@
     FD_ZERO(&wrfds);
 #endif
 	
-    /* HACK: flimsy wiring for davWrite */
-    if (fd->req != NULL)
-	return 1;
-
     if ((fdno = fdFileno(fd)) < 0)
 	return -1;	/* XXX W2DO? */
 	
@@ -599,10 +574,6 @@
     FD_ZERO(&rdfds);
 #endif
 
-    /* HACK: flimsy wiring for davRead */
-    if (fd->req != NULL)
-	return 1;
-
     if ((fdno = fdFileno(fd)) < 0)
 	return -1;	/* XXX W2DO? */
 	
@@ -2265,29 +2236,6 @@
 	    fd->wr_chunked = 0;
 	}
 	break;
-    case URL_IS_HTTPS:
-    case URL_IS_HTTP:
-    case URL_IS_HKP:
-	fd = davOpen(url, flags, mode, &u);
-	if (fd == NULL || u == NULL)
-	    break;
-
-	cmd = ((flags & O_WRONLY)
-		?  ((flags & O_APPEND) ? "PUT" :
-		   ((flags & O_CREAT) ? "PUT" : "PUT"))
-		: "GET");
-	u->openError = davReq(fd, cmd, path);
-	if (u->openError < 0) {
-	    /* XXX make sure that we can exit through ufdClose */
-	    fd = fdLink(fd, "error ctrl (ufdOpen HTTP)");
-	    fd = fdLink(fd, "error data (ufdOpen HTTP)");
-	} else {
-	    fd->bytesRemain = ((!strcmp(cmd, "GET"))
-		?  fd->contentLength : -1);
-	    fd->wr_chunked = ((!strcmp(cmd, "PUT"))
-		?  fd->wr_chunked : 0);
-	}
-	break;
     case URL_IS_DASH:
 	assert(!(flags & O_RDWR));
 	fd = fdDup( ((flags & O_WRONLY) ? STDOUT_FILENO : STDIN_FILENO) );
@@ -2911,10 +2859,8 @@
 	    if (fd->nfps > 0 && fpno == -1 &&
 		fd->fps[fd->nfps-1].io == ufdio &&
 		fd->fps[fd->nfps-1].fp == fp &&
-		(fd->fps[fd->nfps-1].fdno >= 0 || fd->req != NULL))
+		(fd->fps[fd->nfps-1].fdno >= 0))
 	    {
-		int hadreqpersist = (fd->req != NULL);
-
 		if (fp)
 		    rc = fflush(fp);
 		fd->nfps--;
@@ -2924,26 +2870,9 @@
 /*@-usereleased@*/
 		if (fdGetFdno(fd) >= 0)
 		    break;
-		if (!fd->persist)
-		    hadreqpersist = 0;
 		fdSetFp(fd, NULL);
 		fd->nfps++;
 		if (fp) {
-		    /* HACK: flimsy Keepalive wiring. */
-		    if (hadreqpersist) {
-			fd->nfps--;
-/*@-exposetrans@*/
-			fdSetFp(fd, fp);
-/*@=exposetrans@*/
-/*@-refcounttrans@*/
-			(void) fdClose(fd);
-/*@=refcounttrans@*/
-			fdSetFp(fd, NULL);
-			fd->nfps++;
-/*@-refcounttrans@*/
-			(void) fdClose(fd);
-/*@=refcounttrans@*/
-		    } else
 			rc = fclose(fp);
 		}
 		fdPop(fd);
@@ -3223,7 +3152,7 @@
 if (_rpmio_debug)
 fprintf(stderr, "*** Fopen ufdio path %s fmode %s\n", path, fmode);
 	    fd = ufdOpen(path, flags, perms);
-	    if (fd == NULL || !(fdFileno(fd) >= 0 || fd->req != NULL))
+	    if (fd == NULL || !(fdFileno(fd) >= 0))
 		return fd;
 	    break;
 	default:
@@ -3234,7 +3163,7 @@
 	}
 
 	/* XXX persistent HTTP/1.1 returns the previously opened fp */
-	if (isHTTP && ((fp = fdGetFp(fd)) != NULL) && ((fdno = fdGetFdno(fd)) >= 0 || fd->req != NULL))
+	if (isHTTP && ((fp = fdGetFp(fd)) != NULL) && ((fdno = fdGetFdno(fd)) >= 0))
 	{
 	    /*@+voidabstract@*/
 	    fdPush(fd, fpio, fp, fileno(fp));	/* Push fpio onto stack */
@@ -3276,10 +3205,6 @@
     int i, rc = 0;
 
     if (fd == NULL) return -1;
-    if (fd->req != NULL) {
-	/* HACK: flimsy wiring for neon errors. */
-	rc = (fd->syserrno  || fd->errcookie != NULL) ? -1 : 0;
-    } else
     for (i = fd->nfps; rc == 0 && i >= 0; i--) {
 /*@-boundsread@*/
 	FDSTACK_t * fps = &fd->fps[i];
@@ -3317,9 +3242,6 @@
 {
     int i, rc = -1;
 
-    if (fd->req != NULL)
-	rc = 123456789;	/* HACK: https has no steenkin fileno. */
-    else
     for (i = fd->nfps ; rc == -1 && i >= 0; i--) {
 /*@-boundsread@*/
 	rc = fd->fps[i].fdno;
--- rpm-4.5/rpmio/librpmio.vers~	2008-07-09 12:38:31.000000000 +0300
+++ rpm-4.5/rpmio/librpmio.vers	2008-09-04 17:52:56.158976430 +0300
@@ -29,25 +29,6 @@
     Chmod;
     Chown;
     Chroot;
-    davClose;
-    davClosedir;
-    _dav_debug;
-    davLstat;
-    davmagicdir;
-    davMkdir;
-    davOpen;
-    davOpendir;
-    davRead;
-    davReaddir;
-    davRealpath;
-    davRename;
-    davReq;
-    davResp;
-    davRmdir;
-    davSeek;
-    davStat;
-    davUnlink;
-    davWrite;
     delMacro;
     expandMacros;
     Fclose;
--- rpm-4.5/lib/poptALL.c~	2007-10-23 18:53:08.000000000 +0300
+++ rpm-4.5/lib/poptALL.c	2008-09-04 17:53:21.845642132 +0300
@@ -126,8 +126,6 @@
 extern int _ftp_debug;
 /*@unchecked@*/
 extern int _av_debug;
-/*@unchecked@*/
-extern int _dav_debug;
 
 /*@unchecked@*/
 extern int noLibio;
@@ -424,8 +422,6 @@
 	N_("debug FTP/HTTP data stream"), NULL},
  { "avdebug", '\0', POPT_ARG_VAL|POPT_ARGFLAG_DOC_HIDDEN, &_av_debug, -1,
 	N_("debug argv collections"), NULL},
- { "davdebug", '\0', POPT_ARG_VAL|POPT_ARGFLAG_DOC_HIDDEN, &_dav_debug, -1,
-	N_("debug WebDAV data stream"), NULL},
  { "hdrdebug", '\0', POPT_ARG_VAL|POPT_ARGFLAG_DOC_HIDDEN, &_hdr_debug, -1,
 	NULL, NULL},
  { "miredebug", '\0', POPT_ARG_VAL|POPT_ARGFLAG_DOC_HIDDEN, &_mire_debug, -1,
--- rpm-4.5/rpmio/rpmrpc.c	2008-09-04 17:56:39.132287618 +0300
+++ rpm-4.5/rpmio/rpmrpc.c	2008-09-04 17:57:38.618948392 +0300
@@ -78,10 +78,6 @@
     case URL_IS_FTP:
 	return ftpMkdir(path, mode);
 	/*@notreached@*/ break;
-    case URL_IS_HTTPS:
-    case URL_IS_HTTP:
-	return davMkdir(path, mode);
-	/*@notreached@*/ break;
     case URL_IS_PATH:
 	path = lpath;
 	/*@fallthrough@*/
@@ -105,15 +101,6 @@
     case URL_IS_FTP:
 	return ftpChdir(path);
 	/*@notreached@*/ break;
-    case URL_IS_HTTPS:
-    case URL_IS_HTTP:
-#ifdef	NOTYET
-	return davChdir(path);
-#else
-	errno = EINVAL;		/* XXX W2DO? */
-	return -2;
-#endif
-	/*@notreached@*/ break;
     case URL_IS_PATH:
 	path = lpath;
 	/*@fallthrough@*/
@@ -138,10 +125,6 @@
     case URL_IS_FTP:
 	return ftpRmdir(path);
 	/*@notreached@*/ break;
-    case URL_IS_HTTPS:
-    case URL_IS_HTTP:
-	return davRmdir(path);
-	/*@notreached@*/ break;
     case URL_IS_PATH:
 	path = lpath;
 	/*@fallthrough@*/
@@ -245,10 +228,6 @@
 
     oldut = urlPath(oldpath, &oe);
     switch (oldut) {
-    case URL_IS_HTTPS:
-    case URL_IS_HTTP:
-	return davRename(oldpath, newpath);
-	/*@notreached@*/ break;
     case URL_IS_FTP:		/* XXX WRONG WRONG WRONG */
     case URL_IS_PATH:
     case URL_IS_UNKNOWN:
@@ -343,10 +322,6 @@
     case URL_IS_FTP:
 	return ftpUnlink(path);
 	/*@notreached@*/ break;
-    case URL_IS_HTTPS:
-    case URL_IS_HTTP:
-	return davUnlink(path);
-	/*@notreached@*/ break;
     case URL_IS_PATH:
 	path = lpath;
 	/*@fallthrough@*/
@@ -1354,10 +1329,6 @@
     case URL_IS_FTP:
 	return ftpStat(path, st);
 	/*@notreached@*/ break;
-    case URL_IS_HTTPS:
-    case URL_IS_HTTP:
-	return davStat(path, st);
-	/*@notreached@*/ break;
     case URL_IS_PATH:
 	path = lpath;
 	/*@fallthrough@*/
@@ -1384,10 +1355,6 @@
     case URL_IS_FTP:
 	return ftpLstat(path, st);
 	/*@notreached@*/ break;
-    case URL_IS_HTTPS:
-    case URL_IS_HTTP:
-	return davLstat(path, st);
-	/*@notreached@*/ break;
     case URL_IS_PATH:
 	path = lpath;
 	/*@fallthrough@*/
@@ -1630,14 +1597,6 @@
     case URL_IS_FTP:
 	return ftpReadlink(path, buf, bufsiz);
 	/*@notreached@*/ break;
-    case URL_IS_HTTPS:
-    case URL_IS_HTTP:
-#ifdef	NOTYET
-	return davReadlink(path, buf, bufsiz);
-#else
-	return -2;
-#endif
-	/*@notreached@*/ break;
     case URL_IS_PATH:
 	path = lpath;
 	/*@fallthrough@*/
@@ -1787,10 +1746,6 @@
     case URL_IS_FTP:
 	return ftpOpendir(path);
 	/*@notreached@*/ break;
-    case URL_IS_HTTPS:	
-    case URL_IS_HTTP:
-	return davOpendir(path);
-	/*@notreached@*/ break;
     case URL_IS_PATH:
 	path = lpath;
 	/*@fallthrough@*/
@@ -1815,8 +1770,6 @@
 	return NULL;
     if (ISAVMAGIC(dir))
 	return avReaddir(dir);
-    if (ISDAVMAGIC(dir))
-	return davReaddir(dir);
     return readdir(dir);
 }
 
@@ -1828,8 +1781,6 @@
 	return 0;
     if (ISAVMAGIC(dir))
 	return avClosedir(dir);
-    if (ISDAVMAGIC(dir))
-	return davClosedir(dir);
     return closedir(dir);
 }
 
@@ -1852,14 +1803,6 @@
     case URL_IS_FTP:
 	return ftpRealpath(path, resolved_path);
 	/*@notreached@*/ break;
-    case URL_IS_HTTPS:	
-    case URL_IS_HTTP:
-    case URL_IS_HKP:
-#ifdef WITH_NEON
-	return davRealpath(path, resolved_path);
-	/*@notreached@*/ break;
-#endif
-	/*@fallthrough@*/
     default:
 	return xstrdup(path);
 	/*@notreached@*/ break;
--- rpm-4.5/./rpmio/rpmio_internal.h~	2008-06-10 02:19:26.000000000 +0300
+++ rpm-4.5/./rpmio/rpmio_internal.h	2008-09-04 18:00:31.015598325 +0300
@@ -182,7 +182,6 @@
 /*@dependent@*/
     void *	url;		/* ufdio: URL info */
 /*@relnull@*/
-    void *	req;		/* ufdio: HTTP request */
 
     int		rd_timeoutsecs;	/* ufdRead: per FD_t timer */
     ssize_t	bytesRemain;	/* ufdio: */
--- rpm-4.5/rpmio/rpmurl.h~	2008-06-10 02:19:26.000000000 +0300
+++ rpm-4.5/rpmio/rpmurl.h	2008-09-04 18:14:00.546141703 +0300
@@ -54,15 +54,6 @@
 /*@relnull@*/
     FD_t data;			/*!< per-xfer data channel */
 
-/*@relnull@*/
-    void * capabilities;	/*!< neon: ne_server_capabilities ptr */
-/*@relnull@*/
-    void * lockstore;		/*!< neon: ne_lock_store ptr */
-/*@relnull@*/
-    void * sess;		/*!< neon: ne_session ptr */
-    off_t current;		/*!< neon: current body offset. */
-    off_t total;		/*!< neon: total body length. */
-    int connstatus;		/*!< neon: connection status. */
 #ifdef  REFERENCE
 typedef enum {
     ne_conn_namelookup,	/* lookup up hostname (info = hostname) */
--- rpm-4.5/rpmio/url.c~	2008-06-10 02:19:26.000000000 +0300
+++ rpm-4.5/rpmio/url.c	2008-09-04 20:05:19.011716915 +0300
@@ -134,7 +134,6 @@
 			(u->scheme ? u->scheme : ""));
 	/*@=usereleased@*/
     }
-    xx = davFree(u);
     u->buf = _free(u->buf);
     u->url = _free(u->url);
     u->scheme = _free((void *)u->scheme);
--- rpm-4.5/perl/Makefile.PL.in~	2008-10-05 01:31:09.000000000 +0300
+++ rpm-4.5/perl/Makefile.PL.in	2008-10-05 01:32:12.688278120 +0300
@@ -12,7 +12,7 @@
     'NAME'		=> 'RPM',
     'VERSION_FROM'	=> 'RPM.pm', # finds $VERSION
     'PREREQ_PM'		=> {}, # e.g., Module::Name => 1.1
-    'LIBS'		=> [join(' ', @ldaddp) . ' ' . join(' ', @ldadd) . ' @LIBS@ @WITH_POPT_LIB@ @WITH_BEECRYPT_LIB@ -lneon'],
+    'LIBS'		=> [join(' ', @ldaddp) . ' ' . join(' ', @ldadd) . ' @LIBS@ @WITH_POPT_LIB@ @WITH_BEECRYPT_LIB@'],
     'DEFINE'		=> join(" ", @defines), # e.g., '-DHAVE_SOMETHING'
     'INC' => join(' ', map { '-I@top_srcdir@/'. $_ } @libdir) . ' @CPPFLAGS@',
     'TYPEMAPS'          => [ 'typemap' ],
--- rpm-4.5/configure.ac.orig	2011-02-21 16:29:42.000000000 +0100
+++ rpm-4.5/configure.ac	2011-02-21 16:31:00.574910173 +0100
@@ -591,28 +591,7 @@
 WITH_NEON_SUBDIR=
 WITH_NEON_INCLUDE=
 WITH_NEON_LIB=
-AC_CHECK_HEADER([neon/ne_session.h], [
-  AC_CHECK_LIB(neon, ne_session_create, [
-    AC_DEFINE(HAVE_LIBNEON, 1, [Define to 1 if you have the 'neon' library (-lneon).])
-    AC_CHECK_LIB(neon, ne_get_response_header, [
-      AC_DEFINE(HAVE_NEON_NE_GET_RESPONSE_HEADER, 1, [Define to 1 if you have ne_get_response_header() in libneon.])
-    ])
-    AC_CHECK_LIB(neon, ne_send_request_chunk, [
-	AC_DEFINE(HAVE_NEON_NE_SEND_REQUEST_CHUNK, 1, [Define to 1 if you have ne_send_request_chunk() in libneon.])
-    ])
-    WITH_NEON_INCLUDE="-I${includedir}/neon"
-    WITH_NEON_LIB="-lneon"
-  ])
-],[
-  if test -d neon ; then
-    AC_DEFINE(HAVE_LIBNEON, 1, [Define to 1 if you have the 'neon' library (-lneon).])
-# XXX HAVE_NEON_NE_GET_RESPONSE_HEADER assumes libneon-0.25 devel internal
-    AC_DEFINE(HAVE_NEON_NE_GET_RESPONSE_HEADER, 1, [Define to 1 if you have ne_get_response_header() in libneon.])
-    WITH_NEON_SUBDIR=neon
-    WITH_NEON_INCLUDE="-I\${top_srcdir}/${WITH_NEON_SUBDIR}/src"
-    WITH_NEON_LIB="\${top_builddir}/${WITH_NEON_SUBDIR}/src/libneon.la"
-  fi
-])
+
 AC_SUBST(WITH_NEON_SUBDIR)
 AC_SUBST(WITH_NEON_INCLUDE)
 AC_SUBST(WITH_NEON_LIB)
